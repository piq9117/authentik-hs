{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema AuthenticatedSession
module AuthentikAPI.Types.AuthenticatedSession where

import qualified AuthentikAPI.Common
import AuthentikAPI.TypeAlias
import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text as Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.AuthenticatedSession@ in the specification.
--
-- AuthenticatedSession Serializer
data AuthenticatedSession = AuthenticatedSession
  { -- | asn: Get ASN Data
    authenticatedSessionAsn :: (AuthentikAPI.Common.Nullable AuthenticatedSessionAsn'NonNullable),
    -- | current: Check if session is currently active session
    authenticatedSessionCurrent :: GHC.Types.Bool,
    -- | expires
    authenticatedSessionExpires :: Data.Text.Internal.Text,
    -- | geo_ip: Get GeoIP Data
    authenticatedSessionGeoIp :: (AuthentikAPI.Common.Nullable AuthenticatedSessionGeoIp'NonNullable),
    -- | last_ip
    authenticatedSessionLastIp :: Data.Text.Internal.Text,
    -- | last_used
    authenticatedSessionLastUsed :: Data.Text.Internal.Text,
    -- | last_user_agent
    authenticatedSessionLastUserAgent :: Data.Text.Internal.Text,
    -- | user
    authenticatedSessionUser :: GHC.Types.Int,
    -- | user_agent: Get parsed user agent
    authenticatedSessionUserAgent :: AuthenticatedSessionUserAgent',
    -- | uuid
    authenticatedSessionUuid :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON AuthenticatedSession where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asn" Data.Aeson.Types.ToJSON..= authenticatedSessionAsn obj] : ["current" Data.Aeson.Types.ToJSON..= authenticatedSessionCurrent obj] : ["expires" Data.Aeson.Types.ToJSON..= authenticatedSessionExpires obj] : ["geo_ip" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp obj] : ["last_ip" Data.Aeson.Types.ToJSON..= authenticatedSessionLastIp obj] : ["last_used" Data.Aeson.Types.ToJSON..= authenticatedSessionLastUsed obj] : ["last_user_agent" Data.Aeson.Types.ToJSON..= authenticatedSessionLastUserAgent obj] : ["user" Data.Aeson.Types.ToJSON..= authenticatedSessionUser obj] : ["user_agent" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("uuid" Data.Aeson.Types.ToJSON..=)) (authenticatedSessionUuid obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asn" Data.Aeson.Types.ToJSON..= authenticatedSessionAsn obj] : ["current" Data.Aeson.Types.ToJSON..= authenticatedSessionCurrent obj] : ["expires" Data.Aeson.Types.ToJSON..= authenticatedSessionExpires obj] : ["geo_ip" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp obj] : ["last_ip" Data.Aeson.Types.ToJSON..= authenticatedSessionLastIp obj] : ["last_used" Data.Aeson.Types.ToJSON..= authenticatedSessionLastUsed obj] : ["last_user_agent" Data.Aeson.Types.ToJSON..= authenticatedSessionLastUserAgent obj] : ["user" Data.Aeson.Types.ToJSON..= authenticatedSessionUser obj] : ["user_agent" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("uuid" Data.Aeson.Types.ToJSON..=)) (authenticatedSessionUuid obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON AuthenticatedSession where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "AuthenticatedSession" (\obj -> (((((((((GHC.Base.pure AuthenticatedSession GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "current")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "expires")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "geo_ip")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_ip")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_used")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_user_agent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "user")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "user_agent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "uuid"))

-- | Create a new 'AuthenticatedSession' with all required fields.
mkAuthenticatedSession ::
  -- | 'authenticatedSessionAsn'
  AuthentikAPI.Common.Nullable AuthenticatedSessionAsn'NonNullable ->
  -- | 'authenticatedSessionCurrent'
  GHC.Types.Bool ->
  -- | 'authenticatedSessionExpires'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionGeoIp'
  AuthentikAPI.Common.Nullable AuthenticatedSessionGeoIp'NonNullable ->
  -- | 'authenticatedSessionLastIp'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionLastUsed'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionLastUserAgent'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUser'
  GHC.Types.Int ->
  -- | 'authenticatedSessionUserAgent'
  AuthenticatedSessionUserAgent' ->
  AuthenticatedSession
mkAuthenticatedSession authenticatedSessionAsn authenticatedSessionCurrent authenticatedSessionExpires authenticatedSessionGeoIp authenticatedSessionLastIp authenticatedSessionLastUsed authenticatedSessionLastUserAgent authenticatedSessionUser authenticatedSessionUserAgent =
  AuthenticatedSession
    { authenticatedSessionAsn = authenticatedSessionAsn,
      authenticatedSessionCurrent = authenticatedSessionCurrent,
      authenticatedSessionExpires = authenticatedSessionExpires,
      authenticatedSessionGeoIp = authenticatedSessionGeoIp,
      authenticatedSessionLastIp = authenticatedSessionLastIp,
      authenticatedSessionLastUsed = authenticatedSessionLastUsed,
      authenticatedSessionLastUserAgent = authenticatedSessionLastUserAgent,
      authenticatedSessionUser = authenticatedSessionUser,
      authenticatedSessionUserAgent = authenticatedSessionUserAgent,
      authenticatedSessionUuid = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.AuthenticatedSession.properties.asn@ in the specification.
--
-- Get ASN Data
data AuthenticatedSessionAsn'NonNullable = AuthenticatedSessionAsn'NonNullable
  { -- | as_org
    authenticatedSessionAsn'NonNullableAsOrg :: (AuthentikAPI.Common.Nullable Data.Text.Internal.Text),
    -- | asn
    authenticatedSessionAsn'NonNullableAsn :: GHC.Types.Int,
    -- | network
    authenticatedSessionAsn'NonNullableNetwork :: (AuthentikAPI.Common.Nullable Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON AuthenticatedSessionAsn'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["as_org" Data.Aeson.Types.ToJSON..= authenticatedSessionAsn'NonNullableAsOrg obj] : ["asn" Data.Aeson.Types.ToJSON..= authenticatedSessionAsn'NonNullableAsn obj] : ["network" Data.Aeson.Types.ToJSON..= authenticatedSessionAsn'NonNullableNetwork obj] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["as_org" Data.Aeson.Types.ToJSON..= authenticatedSessionAsn'NonNullableAsOrg obj] : ["asn" Data.Aeson.Types.ToJSON..= authenticatedSessionAsn'NonNullableAsn obj] : ["network" Data.Aeson.Types.ToJSON..= authenticatedSessionAsn'NonNullableNetwork obj] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON AuthenticatedSessionAsn'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "AuthenticatedSessionAsn'NonNullable" (\obj -> ((GHC.Base.pure AuthenticatedSessionAsn'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "as_org")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "network"))

-- | Create a new 'AuthenticatedSessionAsn'NonNullable' with all required fields.
mkAuthenticatedSessionAsn'NonNullable ::
  -- | 'authenticatedSessionAsn'NonNullableAsOrg'
  AuthentikAPI.Common.Nullable Data.Text.Internal.Text ->
  -- | 'authenticatedSessionAsn'NonNullableAsn'
  GHC.Types.Int ->
  -- | 'authenticatedSessionAsn'NonNullableNetwork'
  AuthentikAPI.Common.Nullable Data.Text.Internal.Text ->
  AuthenticatedSessionAsn'NonNullable
mkAuthenticatedSessionAsn'NonNullable authenticatedSessionAsn'NonNullableAsOrg authenticatedSessionAsn'NonNullableAsn authenticatedSessionAsn'NonNullableNetwork =
  AuthenticatedSessionAsn'NonNullable
    { authenticatedSessionAsn'NonNullableAsOrg = authenticatedSessionAsn'NonNullableAsOrg,
      authenticatedSessionAsn'NonNullableAsn = authenticatedSessionAsn'NonNullableAsn,
      authenticatedSessionAsn'NonNullableNetwork = authenticatedSessionAsn'NonNullableNetwork
    }

-- | Defines the object schema located at @components.schemas.AuthenticatedSession.properties.geo_ip@ in the specification.
--
-- Get GeoIP Data
data AuthenticatedSessionGeoIp'NonNullable = AuthenticatedSessionGeoIp'NonNullable
  { -- | city
    authenticatedSessionGeoIp'NonNullableCity :: Data.Text.Internal.Text,
    -- | continent
    authenticatedSessionGeoIp'NonNullableContinent :: Data.Text.Internal.Text,
    -- | country
    authenticatedSessionGeoIp'NonNullableCountry :: Data.Text.Internal.Text,
    -- | lat
    authenticatedSessionGeoIp'NonNullableLat :: GHC.Types.Double,
    -- | long
    authenticatedSessionGeoIp'NonNullableLong :: GHC.Types.Double
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON AuthenticatedSessionGeoIp'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["city" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableCity obj] : ["continent" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableContinent obj] : ["country" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableCountry obj] : ["lat" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableLat obj] : ["long" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableLong obj] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["city" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableCity obj] : ["continent" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableContinent obj] : ["country" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableCountry obj] : ["lat" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableLat obj] : ["long" Data.Aeson.Types.ToJSON..= authenticatedSessionGeoIp'NonNullableLong obj] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON AuthenticatedSessionGeoIp'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "AuthenticatedSessionGeoIp'NonNullable" (\obj -> ((((GHC.Base.pure AuthenticatedSessionGeoIp'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "continent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "lat")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "long"))

-- | Create a new 'AuthenticatedSessionGeoIp'NonNullable' with all required fields.
mkAuthenticatedSessionGeoIp'NonNullable ::
  -- | 'authenticatedSessionGeoIp'NonNullableCity'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionGeoIp'NonNullableContinent'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionGeoIp'NonNullableCountry'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionGeoIp'NonNullableLat'
  GHC.Types.Double ->
  -- | 'authenticatedSessionGeoIp'NonNullableLong'
  GHC.Types.Double ->
  AuthenticatedSessionGeoIp'NonNullable
mkAuthenticatedSessionGeoIp'NonNullable authenticatedSessionGeoIp'NonNullableCity authenticatedSessionGeoIp'NonNullableContinent authenticatedSessionGeoIp'NonNullableCountry authenticatedSessionGeoIp'NonNullableLat authenticatedSessionGeoIp'NonNullableLong =
  AuthenticatedSessionGeoIp'NonNullable
    { authenticatedSessionGeoIp'NonNullableCity = authenticatedSessionGeoIp'NonNullableCity,
      authenticatedSessionGeoIp'NonNullableContinent = authenticatedSessionGeoIp'NonNullableContinent,
      authenticatedSessionGeoIp'NonNullableCountry = authenticatedSessionGeoIp'NonNullableCountry,
      authenticatedSessionGeoIp'NonNullableLat = authenticatedSessionGeoIp'NonNullableLat,
      authenticatedSessionGeoIp'NonNullableLong = authenticatedSessionGeoIp'NonNullableLong
    }

-- | Defines the object schema located at @components.schemas.AuthenticatedSession.properties.user_agent@ in the specification.
--
-- Get parsed user agent
data AuthenticatedSessionUserAgent' = AuthenticatedSessionUserAgent'
  { -- | device: User agent device
    authenticatedSessionUserAgent'Device :: AuthenticatedSessionUserAgent'Device',
    -- | os: User agent os
    authenticatedSessionUserAgent'Os :: AuthenticatedSessionUserAgent'Os',
    -- | string
    authenticatedSessionUserAgent'String :: Data.Text.Internal.Text,
    -- | user_agent: User agent browser
    authenticatedSessionUserAgent'UserAgent :: AuthenticatedSessionUserAgent'UserAgent'
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON AuthenticatedSessionUserAgent' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["device" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Device obj] : ["os" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os obj] : ["string" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'String obj] : ["user_agent" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent obj] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["device" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Device obj] : ["os" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os obj] : ["string" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'String obj] : ["user_agent" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent obj] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON AuthenticatedSessionUserAgent' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "AuthenticatedSessionUserAgent'" (\obj -> (((GHC.Base.pure AuthenticatedSessionUserAgent' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "device")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "os")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "string")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "user_agent"))

-- | Create a new 'AuthenticatedSessionUserAgent'' with all required fields.
mkAuthenticatedSessionUserAgent' ::
  -- | 'authenticatedSessionUserAgent'Device'
  AuthenticatedSessionUserAgent'Device' ->
  -- | 'authenticatedSessionUserAgent'Os'
  AuthenticatedSessionUserAgent'Os' ->
  -- | 'authenticatedSessionUserAgent'String'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'UserAgent'
  AuthenticatedSessionUserAgent'UserAgent' ->
  AuthenticatedSessionUserAgent'
mkAuthenticatedSessionUserAgent' authenticatedSessionUserAgent'Device authenticatedSessionUserAgent'Os authenticatedSessionUserAgent'String authenticatedSessionUserAgent'UserAgent =
  AuthenticatedSessionUserAgent'
    { authenticatedSessionUserAgent'Device = authenticatedSessionUserAgent'Device,
      authenticatedSessionUserAgent'Os = authenticatedSessionUserAgent'Os,
      authenticatedSessionUserAgent'String = authenticatedSessionUserAgent'String,
      authenticatedSessionUserAgent'UserAgent = authenticatedSessionUserAgent'UserAgent
    }

-- | Defines the object schema located at @components.schemas.AuthenticatedSession.properties.user_agent.properties.device@ in the specification.
--
-- User agent device
data AuthenticatedSessionUserAgent'Device' = AuthenticatedSessionUserAgent'Device'
  { -- | brand
    authenticatedSessionUserAgent'Device'Brand :: Data.Text.Internal.Text,
    -- | family
    authenticatedSessionUserAgent'Device'Family :: Data.Text.Internal.Text,
    -- | model
    authenticatedSessionUserAgent'Device'Model :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON AuthenticatedSessionUserAgent'Device' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["brand" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Device'Brand obj] : ["family" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Device'Family obj] : ["model" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Device'Model obj] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["brand" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Device'Brand obj] : ["family" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Device'Family obj] : ["model" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Device'Model obj] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON AuthenticatedSessionUserAgent'Device' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "AuthenticatedSessionUserAgent'Device'" (\obj -> ((GHC.Base.pure AuthenticatedSessionUserAgent'Device' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "brand")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "family")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "model"))

-- | Create a new 'AuthenticatedSessionUserAgent'Device'' with all required fields.
mkAuthenticatedSessionUserAgent'Device' ::
  -- | 'authenticatedSessionUserAgent'Device'Brand'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'Device'Family'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'Device'Model'
  Data.Text.Internal.Text ->
  AuthenticatedSessionUserAgent'Device'
mkAuthenticatedSessionUserAgent'Device' authenticatedSessionUserAgent'Device'Brand authenticatedSessionUserAgent'Device'Family authenticatedSessionUserAgent'Device'Model =
  AuthenticatedSessionUserAgent'Device'
    { authenticatedSessionUserAgent'Device'Brand = authenticatedSessionUserAgent'Device'Brand,
      authenticatedSessionUserAgent'Device'Family = authenticatedSessionUserAgent'Device'Family,
      authenticatedSessionUserAgent'Device'Model = authenticatedSessionUserAgent'Device'Model
    }

-- | Defines the object schema located at @components.schemas.AuthenticatedSession.properties.user_agent.properties.os@ in the specification.
--
-- User agent os
data AuthenticatedSessionUserAgent'Os' = AuthenticatedSessionUserAgent'Os'
  { -- | family
    authenticatedSessionUserAgent'Os'Family :: Data.Text.Internal.Text,
    -- | major
    authenticatedSessionUserAgent'Os'Major :: Data.Text.Internal.Text,
    -- | minor
    authenticatedSessionUserAgent'Os'Minor :: Data.Text.Internal.Text,
    -- | patch
    authenticatedSessionUserAgent'Os'Patch :: Data.Text.Internal.Text,
    -- | patch_minor
    authenticatedSessionUserAgent'Os'PatchMinor :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON AuthenticatedSessionUserAgent'Os' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["family" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'Family obj] : ["major" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'Major obj] : ["minor" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'Minor obj] : ["patch" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'Patch obj] : ["patch_minor" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'PatchMinor obj] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["family" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'Family obj] : ["major" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'Major obj] : ["minor" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'Minor obj] : ["patch" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'Patch obj] : ["patch_minor" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'Os'PatchMinor obj] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON AuthenticatedSessionUserAgent'Os' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "AuthenticatedSessionUserAgent'Os'" (\obj -> ((((GHC.Base.pure AuthenticatedSessionUserAgent'Os' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "family")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "major")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "minor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "patch")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "patch_minor"))

-- | Create a new 'AuthenticatedSessionUserAgent'Os'' with all required fields.
mkAuthenticatedSessionUserAgent'Os' ::
  -- | 'authenticatedSessionUserAgent'Os'Family'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'Os'Major'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'Os'Minor'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'Os'Patch'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'Os'PatchMinor'
  Data.Text.Internal.Text ->
  AuthenticatedSessionUserAgent'Os'
mkAuthenticatedSessionUserAgent'Os' authenticatedSessionUserAgent'Os'Family authenticatedSessionUserAgent'Os'Major authenticatedSessionUserAgent'Os'Minor authenticatedSessionUserAgent'Os'Patch authenticatedSessionUserAgent'Os'PatchMinor =
  AuthenticatedSessionUserAgent'Os'
    { authenticatedSessionUserAgent'Os'Family = authenticatedSessionUserAgent'Os'Family,
      authenticatedSessionUserAgent'Os'Major = authenticatedSessionUserAgent'Os'Major,
      authenticatedSessionUserAgent'Os'Minor = authenticatedSessionUserAgent'Os'Minor,
      authenticatedSessionUserAgent'Os'Patch = authenticatedSessionUserAgent'Os'Patch,
      authenticatedSessionUserAgent'Os'PatchMinor = authenticatedSessionUserAgent'Os'PatchMinor
    }

-- | Defines the object schema located at @components.schemas.AuthenticatedSession.properties.user_agent.properties.user_agent@ in the specification.
--
-- User agent browser
data AuthenticatedSessionUserAgent'UserAgent' = AuthenticatedSessionUserAgent'UserAgent'
  { -- | family
    authenticatedSessionUserAgent'UserAgent'Family :: Data.Text.Internal.Text,
    -- | major
    authenticatedSessionUserAgent'UserAgent'Major :: Data.Text.Internal.Text,
    -- | minor
    authenticatedSessionUserAgent'UserAgent'Minor :: Data.Text.Internal.Text,
    -- | patch
    authenticatedSessionUserAgent'UserAgent'Patch :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON AuthenticatedSessionUserAgent'UserAgent' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["family" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent'Family obj] : ["major" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent'Major obj] : ["minor" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent'Minor obj] : ["patch" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent'Patch obj] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["family" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent'Family obj] : ["major" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent'Major obj] : ["minor" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent'Minor obj] : ["patch" Data.Aeson.Types.ToJSON..= authenticatedSessionUserAgent'UserAgent'Patch obj] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON AuthenticatedSessionUserAgent'UserAgent' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "AuthenticatedSessionUserAgent'UserAgent'" (\obj -> (((GHC.Base.pure AuthenticatedSessionUserAgent'UserAgent' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "family")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "major")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "minor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "patch"))

-- | Create a new 'AuthenticatedSessionUserAgent'UserAgent'' with all required fields.
mkAuthenticatedSessionUserAgent'UserAgent' ::
  -- | 'authenticatedSessionUserAgent'UserAgent'Family'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'UserAgent'Major'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'UserAgent'Minor'
  Data.Text.Internal.Text ->
  -- | 'authenticatedSessionUserAgent'UserAgent'Patch'
  Data.Text.Internal.Text ->
  AuthenticatedSessionUserAgent'UserAgent'
mkAuthenticatedSessionUserAgent'UserAgent' authenticatedSessionUserAgent'UserAgent'Family authenticatedSessionUserAgent'UserAgent'Major authenticatedSessionUserAgent'UserAgent'Minor authenticatedSessionUserAgent'UserAgent'Patch =
  AuthenticatedSessionUserAgent'UserAgent'
    { authenticatedSessionUserAgent'UserAgent'Family = authenticatedSessionUserAgent'UserAgent'Family,
      authenticatedSessionUserAgent'UserAgent'Major = authenticatedSessionUserAgent'UserAgent'Major,
      authenticatedSessionUserAgent'UserAgent'Minor = authenticatedSessionUserAgent'UserAgent'Minor,
      authenticatedSessionUserAgent'UserAgent'Patch = authenticatedSessionUserAgent'UserAgent'Patch
    }
